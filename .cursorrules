# .cursorrules — Next.js Development Rules

You are building an application as described in Project.md.
Always align with Project.md.
Do not invent features, workflows, data models, or assumptions that are not explicitly in scope.

────────────────────────────────────────
PRIME DIRECTIVES
────────────────────────────────────────
- Follow Project.md as the single source of truth.
- If something is unclear or missing, ask for clarification instead of guessing.
- Make small, incremental, testable changes.
- Keep the application deployable at all times.
- Do not refactor unrelated code unless explicitly requested.

────────────────────────────────────────
NEXT.JS ARCHITECTURE
────────────────────────────────────────
- Use the App Router (`app/`) exclusively.
- Prefer Server Components by default.
- Add `"use client"` only when required:
  - React hooks
  - browser APIs
  - event handlers
- Never mix server-only logic into client components.

────────────────────────────────────────
PROJECT STRUCTURE
────────────────────────────────────────
- `app/` → routes, layouts, pages
- `app/api/` → route handlers (`route.ts`)
- `components/` → reusable UI components
- `components/ui/` → presentational components only
- `lib/` → shared utilities and helpers
- `lib/server/` → server-only logic (never imported by client code)
- `hooks/` → custom React hooks
- `types/` → shared TypeScript types

────────────────────────────────────────
FILE & NAMING CONVENTIONS
────────────────────────────────────────
- File names: kebab-case
- React components: PascalCase
- Utility files: lowercase or camelCase
- Pages: `page.tsx`
- Layouts: `layout.tsx`
- Loading states: `loading.tsx`
- Error boundaries: `error.tsx`

────────────────────────────────────────
TYPE SAFETY
────────────────────────────────────────
- Use TypeScript everywhere.
- Avoid `any`.
- Use `unknown` and narrow explicitly.
- Define explicit types for:
  - component props
  - API request and response payloads
  - shared data structures

────────────────────────────────────────
STATE MANAGEMENT
────────────────────────────────────────
- Prefer local component state first.
- Use React Context only for shared, cross-component state.
- Do not introduce external state libraries unless justified.
- Keep state minimal and serializable.

────────────────────────────────────────
DATA FETCHING & SIDE EFFECTS
────────────────────────────────────────
- Prefer server-side data fetching in Server Components.
- Use route handlers for mutations and side effects.
- Do not call external services directly from client components.
- Handle loading and error states explicitly.

────────────────────────────────────────
API ROUTES (ROUTE HANDLERS)
────────────────────────────────────────
- Use `app/api/**/route.ts`.
- Validate input on the server.
- Return consistent JSON shapes.
- Always return appropriate HTTP status codes.
- Never expose secrets or internal stack traces.

────────────────────────────────────────
SECURITY & SECRETS
────────────────────────────────────────
- Never expose secrets to the client.
- Never hardcode credentials.
- Use environment variables for all secrets.
- Keep secret usage confined to server-only files.
- Validate and sanitize all user input.

────────────────────────────────────────
STYLING & THEME GUIDELINES
────────────────────────────────────────
- Use Tailwind CSS or CSS Modules.
- Keep styling consistent and utility-first.
- Avoid large monolithic components.
- Prefer composition over inheritance.

CSS Variable Pattern:
- Always define new colors in CSS variable system first (in globals.css).
- Never use hardcoded hex/rgb colors in components.
- Use semantic variable names (--error, --success) not color names (--red-500).
- All colors must have both dark and light theme values.
- Variables are defined in :root/.dark (dark theme) and .light (light theme) sections.
- Map new variables to Tailwind utilities in @theme inline section.

Theme-Aware Development:
- All colors must work in both dark and light themes automatically.
- Test components in both themes during development.
- Use CSS variables via Tailwind mapped classes (bg-background, text-foreground) or semantic utilities.
- Never use Tailwind color utilities directly (e.g., text-red-600, bg-green-500) for theme-aware colors.
- Use semantic utility classes when available: text-error, bg-success, etc.

Color System:
- Background: --background, --background-secondary, --background-tertiary
- Foreground: --foreground, --foreground-secondary, --foreground-muted
- Borders: --border, --border-light
- Accent: --accent, --accent-hover
- Status: --error, --error-hover, --success, --success-hover
- Navbar: --navbar-bg, --navbar-border, --navbar-shadow

Transition Standards:
- Global theme transitions: 500ms (handled automatically via * selector in globals.css).
- Component interactions (hover, focus): 300ms.
- Use transition-colors for color changes.
- Use transition-opacity for opacity changes.
- Use transition-transform for transforms.

Hover Pattern Standards:
- Default interactive hover: hover:opacity-80 (for simple opacity-based interactions).
- Color-based hover: Use CSS variable hovers (hover:bg-accent-hover, hover:text-foreground-muted).
- Maintain consistency across similar components.
- Special cases (like logo-strip) may use different opacity values for visual effect.

Utility Class Pattern:
- Prefer semantic utility classes (text-error, bg-success) over Tailwind color utilities.
- Create new utilities in globals.css when needed for semantic meaning.
- Use Tailwind utilities for layout, spacing, typography.
- Keep component-specific CSS classes minimal and semantic.

Component Styling Best Practices:
- Use Tailwind utilities for layout, spacing, typography.
- Use CSS variables for colors (via Tailwind mapped classes or direct var()).
- Keep component CSS classes simple and semantic.
- Document any component-specific styling decisions.
- When adding new status colors or semantic colors, add to CSS variable system first.

────────────────────────────────────────
PERFORMANCE
────────────────────────────────────────
- Minimize client-side JavaScript.
- Avoid unnecessary `"use client"`.
- Use dynamic imports for heavy components.
- Use `next/image` and `next/font` where appropriate.

────────────────────────────────────────
ERROR HANDLING
────────────────────────────────────────
- Use `error.tsx` for route-level error boundaries.
- Show user-friendly error messages.
- Log errors server-side.
- Never leak sensitive details to the client.

────────────────────────────────────────
DOCUMENTATION DISCIPLINE
────────────────────────────────────────
- Before making meaningful changes:
  - State the intent clearly.
- After making changes:
  - Summarize what changed and why.
- Keep Project.md or README.md updated.
- Document new environment variables or setup steps.

────────────────────────────────────────
CURSOR DEVELOPMENT BEHAVIOR
────────────────────────────────────────
When implementing a feature:
1. Reconfirm the goal against Project.md.
2. Identify the minimal set of files to change.
3. Implement the smallest working solution.
4. Avoid premature abstraction or optimization.
5. Prefer readability over cleverness.

────────────────────────────────────────
NON-GOALS
────────────────────────────────────────
- Do not assume business rules or workflows.
- Do not introduce libraries or patterns without justification.
- Do not optimize for scale prematurely.
- Do not mix client and server responsibilities.

End of rules.
